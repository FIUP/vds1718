\newcommand{\repeatSbS}[3]{\texttt{repeat}~#1~\texttt{test}~#2~\texttt{then}~#3}

\exercise{Esercizio 3}
{
	Assume that the language $\textbf{While}^{\textbf{+}}$ includes a new
	iterative command
	\begin{center}
	\repeatSbS{$S_1$}{$b$}{$S_2$}
	\end{center}
	where $b~\in~\bexp$ and $S_1,~S_2~\in~\stm$, whose informal semantics goes
	as follows:\\The following three steps are iteratively executed:
	\begin{enumerate}
	\item the command $S_1$ is executed
	\item the Boolean expression $b$ is evaluated; if $b$ evaluates to 
	\emph{false} then the loop is exited, otherwise the loop proceeds with step
	3
	\item command $S_2$ is executed
	\end{enumerate}
	\begin{itemize}
	\item [(a)] Define the small step operational semantics of this new
	iterative command.
	\item [(b)] Find a program \textbf{P} in the basic language \textbf{While} such that
	\begin{center}
	$\repeatSbS{$S_1$}{$b$}{$S_2$}~\cong_{sos}~P$
	\end{center}
	and formally prove this semantic equivalence.
	\end{itemize}
}
{
	\hspace*{\textwidth-}

	\textbf{Parte (a)}
	\begin{center}
	$\confSs{\repeatSbS{S_1}{b}{S_2}}{s}~\Rar{[repeat_{sos}]}~
	\confSs{\concat
	{$S_1$}
	{\ifABC{b}{\concat
	{$S_2$}
	{(\repeatSbS{$S_1$}{$b$}{$S_2$})}
	}{\skipistr}}
	}{s}$
	\end{center}
	L'idea di base Ã¨ mimare esattamente quando descritto nella prima parte
	della consegna, eseguendo qualcosa di simile all'\emph{unfolding} della
	regola del while in semantica \texttt{SOS}. Per questo il comando
	\texttt{repeat} viene trasformato nella concatenazione del sottoprogramma
	$S_1$, che deve essere in ogni caso eseguito, con un \texttt{if}. Nel caso
	la valutazione della guardia dell'\texttt{if} (la stessa guardia
	specificata nel comando del \texttt{repeat}) sia falsa nello stato $s$
	allora il \texttt{repeat} evolve in \skipistr{}. Viceversa, se la guardia
	viene valutata a \texttt{true}, allora il \texttt{repeat} evolve nella
	concatenazione tra il sottoprogramma $S_2$ e la ripetizione del 
	\texttt{repeat}, in modo tale da permettere la ripetizione iterativa.\\

	\textbf{Parte (b)}
}